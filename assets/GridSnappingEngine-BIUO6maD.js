import{gT as D,dL as W,o2 as O,bK as U,at as E,iS as F,au as T,o3 as q,o4 as H,S as I,db as L,o5 as _,ha as j,o6 as K,o7 as y,bl as N,fX as k,o8 as A,o9 as B,oa as X,ob as J,oc as Q,od as z,_ as l,m as c,b as Z}from"./index-C5z1JKvU.js";const ee=50,te=5;function re(e,r){return Math.log(e)/Math.log(r)}function ne(e,r,t){const i=e===1?10:e;return i**(t?Math.round(re(ee/r,i)):0)}function ie(e){const{isGeographic:r,isWebMercator:t}=e;return!r&&!t}function se(e,r,t){const i=typeof e=="number"?null:e,n=t??i?.spatialReference;if(n==null||!D(n)||ie(n))return W(n);let s=i?.x??e,a=i?.y??r;const g=1/Math.sqrt(2);let p=s+g,f=a+g;const{isWebMercator:h,isGeographic:R}=n;let w=R&&!O(n)?U.WGS84:n;if(h){let u=new E({x:s,y:a,spatialReference:n});F(u,!0,u),s=u.x,a=u.y,u=new E({x:p,y:f,spatialReference:n}),F(u,!0,u),p=u.x,f=u.y,w=U.WGS84}const v=new T({paths:[[[s,a],[p,f]]],spatialReference:w}),b=q(v,10);let d;try{[d]=H([b],"meters")}catch{return W(n)}return d}let o=class extends I{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){return this.grid?.rotateWithMap?0:L(this.view.rotation??0)}get gridRotation(){return L(this.grid?.rotation??0)}get gridCenter(){const{spatialReference:e,grid:r}=this;if(!r||!e||!_(r.center.spatialReference,e))return null;try{const t=j(r.center,e),i=e.isWrappable&&this.view?.center!=null?K(t.x,this.view.center.x,e):t.x;return y(i,t.y,t.z)}catch(t){return N.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",t),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:r}=this;if(!r||!e)return 1;const{majorLineInterval:t,dynamicScaling:i}=r;return t<1?null:ne(t,e,i)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?k(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return e==null?null:e*A(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?se(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:r}=this;return r&&e?e/r:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,r,t){const{options:i,view:n}=this;if(!i?.effectiveGridEnabled||!n.grid||t.feature?.attributes&&B in t.feature.attributes)return[];const s=t.coordinateHelper.arrayToPoint(e),a=i.distance*(t.pointer==="touch"?i.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,a)}fetchCandidatesSync(e,r){const t=[],{grid:i,effectiveViewRotation:n,gridRotation:s,gridCenter:a,viewMetersPerPixel:g,viewMetersPerSRUnit:p,offsetScaleFactor:f,spatialReference:h,gridMetersPerStride:R,pixelsPerStride:w}=this;if(!(i&&g&&p&&a&&h&&f&&R&&w)||!i.dynamicScaling&&w<te||!_(e.spatialReference,h))return t;const v=j(e,h),b=y(v.x,v.y,v.z),d=M(b,-s,a,-n),u=R/p*f,S=ae(d,u,a),{shouldSnapX:P,shouldSnapY:x}=oe(S,d,r,g,p);if(!P&&!x)return[];const Y=y((P?S:d)[0],(x?S:d)[1]),$=M(Y,s,a,n),G=M(S,s,a,n);if(x){const m=V(S,d,u,"y"),C=M(m,s,a,n);t.push(new X({lineStart:G,lineEnd:C,targetPoint:$,isDraped:!1}))}if(P){const m=V(S,d,u,"x"),C=M(m,s,a,n);t.push(new X({lineStart:G,lineEnd:C,targetPoint:$,isDraped:!1}))}return P&&x&&t.push(new J($,t[0],t[1],!1)),t}};l([c({constructOnly:!0})],o.prototype,"view",void 0),l([c()],o.prototype,"options",void 0),l([c()],o.prototype,"grid",null),l([c()],o.prototype,"effectiveViewRotation",null),l([c()],o.prototype,"gridRotation",null),l([c()],o.prototype,"gridCenter",null),l([c()],o.prototype,"offsetScaleFactor",null),l([c()],o.prototype,"spatialReference",null),l([c()],o.prototype,"gridMetersPerStride",null),l([c()],o.prototype,"viewMetersPerPixel",null),l([c()],o.prototype,"viewMetersPerSRUnit",null),l([c()],o.prototype,"pixelsPerStride",null),l([c()],o.prototype,"updating",null),o=l([Z("esri.views.interactive.snapping.GridSnappingEngine")],o);const M=(e,r,t,i)=>{const n=Q(e[0],e[1],e[2]);return z(n,z(n,n,t,r),t,i)},ae=(e,r,t)=>{const i=(e[0]-t[0])/r,n=(e[1]-t[1])/r,s=Math.trunc(i),a=Math.trunc(n),g=Math.round(i%1),p=Math.round(n%1),f=t[0]+(s+g)*r,h=t[1]+(a+p)*r;return y(f,h)},oe=(e,r,t,i,n)=>{if(i<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-r[0])/i,a=(e[1]-r[1])/i;return{shouldSnapX:Math.abs(s*n)<t,shouldSnapY:Math.abs(a*n)<t}},V=(e,r,t,i)=>{if(i==="y"){const s=r[0]>e[0]?1:-1;return y(e[0]+t*s,e[1])}const n=r[1]>e[1]?1:-1;return y(e[0],e[1]+t*n)};export{o as GridSnappingEngine};
